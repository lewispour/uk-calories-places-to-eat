const fs = require('fs');
const path = require('path');

const placesPath = path.resolve(__dirname, '..', 'places.md');
const outputPath = path.resolve(__dirname, '..', 'src', 'lib', 'data.ts');

const parsePlacesData = (content) => {
  const lines = content.split(/\r?\n/);
  const categories = [];
  let currentCategory = null;
  let currentPlaces = [];

  for (const line of lines) {
    const trimmedLine = line.trim();

    if (!trimmedLine || trimmedLine === 'uk') continue;

    if (!trimmedLine.startsWith('*') && !trimmedLine.startsWith('[')) {
      if (currentCategory && currentPlaces.length > 0) {
        categories.push({
          name: currentCategory,
          places: currentPlaces,
        });
      }

      currentCategory = trimmedLine;
      currentPlaces = [];
      continue;
    }

    if (trimmedLine.startsWith('*')) {
      const nameStart = trimmedLine.indexOf('[');
      const nameEnd = trimmedLine.indexOf('](');
      if (nameStart === -1 || nameEnd === -1) continue;

      const name = trimmedLine.slice(nameStart + 1, nameEnd);
      let urlStart = nameEnd + 2;
      let urlEnd = -1;
      let escaped = false;

      for (let i = urlStart; i < trimmedLine.length; i += 1) {
        const char = trimmedLine[i];
        if (escaped) {
          escaped = false;
          continue;
        }
        if (char === '\\') {
          escaped = true;
          continue;
        }
        if (char === ')') {
          urlEnd = i;
          break;
        }
      }

      if (urlEnd === -1) continue;

      const rawUrl = trimmedLine.slice(urlStart, urlEnd);
      const notes = trimmedLine.slice(urlEnd + 1);
      const cleanNotes = notes
        ? notes
            .trim()
            .replace(/^\\\*\s*/, '')
            .replace(/^\\-\s*/, '')
            .replace(/^\s*-\s*/, '')
        : '';

      currentPlaces.push({
        name: name.trim(),
        url: rawUrl.replace(/\\([()])/g, '$1').trim(),
        category: currentCategory || '',
        notes: cleanNotes || undefined,
      });
    }
  }

  if (currentCategory && currentPlaces.length > 0) {
    categories.push({
      name: currentCategory,
      places: currentPlaces,
    });
  }

  return categories;
};

const placesContent = fs.readFileSync(placesPath, 'utf8');
const categories = parsePlacesData(placesContent);

const fileContents = `// This file is auto-generated by scripts/generate-data.js.
// Do not edit directly; edit places.md instead.

export interface Place {
  name: string;
  url: string;
  category: string;
  notes?: string;
}

export interface Category {
  name: string;
  places: Place[];
}

export const categories: Category[] = ${JSON.stringify(categories, null, 2)};

export const parsePlacesData = (): Category[] => categories;

export const getAllPlaces = (): Place[] => {
  return categories.flatMap(category => category.places);
};

export const getRandomPlace = (selectedCategories?: string[]): Place => {
  let places: Place[];

  if (selectedCategories && selectedCategories.length > 0) {
    places = categories
      .filter(cat => selectedCategories.includes(cat.name))
      .flatMap(cat => cat.places);
  } else {
    places = getAllPlaces();
  }

  return places[Math.floor(Math.random() * places.length)];
};

export const getCategoryNames = (): string[] => {
  return categories.map(cat => cat.name);
};
`;

fs.writeFileSync(outputPath, fileContents, 'utf8');
console.log(`Generated ${path.relative(process.cwd(), outputPath)}`);
